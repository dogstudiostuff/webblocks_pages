{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/continuous-toolbox/webpack/universalModuleDefinition","webpack://@blockly/continuous-toolbox/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/continuous-toolbox/webpack/bootstrap","webpack://@blockly/continuous-toolbox/webpack/runtime/define property getters","webpack://@blockly/continuous-toolbox/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/continuous-toolbox/webpack/runtime/make namespace object","webpack://@blockly/continuous-toolbox/./src/ContinuousCategory.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousToolbox.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousFlyoutMetrics.ts","webpack://@blockly/continuous-toolbox/./src/RecyclableBlockFlyoutInflater.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousFlyout.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousMetrics.ts","webpack://@blockly/continuous-toolbox/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox category with styling for continuous toolbox.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Toolbox category for continuous toolbox. */\nexport class ContinuousCategory extends Blockly.ToolboxCategory {\n  /**\n   * Creates a DOM element to display the category's label.\n   *\n   * @param name The name of this category.\n   * @returns The newly created category label DOM element.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override createLabelDom_(name: string): Element {\n    const label = document.createElement('div');\n    label.setAttribute('id', this.getId() + '.label');\n    label.textContent = name;\n    label.classList.add(this.cssConfig_['label'] ?? '');\n    return label;\n  }\n\n  /**\n   * Creates a DOM element to display the category's icon. This category uses\n   * color swatches instead of graphical icons.\n   *\n   * @returns The newly created category icon DOM element.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override createIconDom_(): Element {\n    const icon = document.createElement('div');\n    icon.classList.add('categoryBubble');\n    icon.style.backgroundColor = this.colour_;\n    return icon;\n  }\n\n  /**\n   * Adds a color indicator to the toolbox category. Intentionally a no-op.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override addColourBorder_() {\n    // No-op\n  }\n\n  /**\n   * Sets whether or not this category is selected in the toolbox.\n   *\n   * @param isSelected True if this category is selected, otherwise false.\n   */\n  override setSelected(isSelected: boolean) {\n    if (!this.rowDiv_ || !this.htmlDiv_) return;\n    if (isSelected) {\n      this.rowDiv_.style.backgroundColor = 'gray';\n      Blockly.utils.dom.addClass(\n        this.rowDiv_,\n        this.cssConfig_['selected'] ?? '',\n      );\n    } else {\n      this.rowDiv_.style.backgroundColor = '';\n      Blockly.utils.dom.removeClass(\n        this.rowDiv_,\n        this.cssConfig_['selected'] ?? '',\n      );\n    }\n    Blockly.utils.aria.setState(\n      this.htmlDiv_,\n      Blockly.utils.aria.State.SELECTED,\n      isSelected,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousFlyout} from './ContinuousFlyout';\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /**\n   * Timeout ID used to prevent refreshing the flyout during extensive block\n   * changes.\n   */\n  private refreshDebouncer?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Initializes the continuous toolbox.\n   */\n  override init() {\n    super.init();\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout();\n    flyout.show(this.getInitialFlyoutContents());\n\n    this.getWorkspace().addChangeListener((e: Blockly.Events.Abstract) => {\n      if (\n        e.type === Blockly.Events.BLOCK_CREATE ||\n        e.type === Blockly.Events.BLOCK_DELETE ||\n        e.type === Blockly.Events.BLOCK_CHANGE\n      ) {\n        this.refreshSelection();\n      }\n    });\n  }\n\n  /**\n   * Returns the continuous toolbox's flyout.\n   *\n   * @returns The toolbox's flyout.\n   */\n  override getFlyout(): ContinuousFlyout {\n    return super.getFlyout() as ContinuousFlyout;\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   *\n   * @returns Flyout contents.\n   */\n  private getInitialFlyoutContents(): Blockly.utils.toolbox.FlyoutItemInfoArray {\n    return this.getToolboxItems().flatMap(this.convertToolboxItemToFlyoutItems);\n  }\n\n  /**\n   * Converts a given toolbox item to an array of flyout items, generally a\n   * label followed by the category's blocks.\n   *\n   * @param toolboxItem The toolbox item/category to convert.\n   * @returns An array of flyout items contained in the given toolbox item.\n   */\n  protected convertToolboxItemToFlyoutItems(\n    toolboxItem: Blockly.IToolboxItem,\n  ): Blockly.utils.toolbox.FlyoutItemInfoArray {\n    let contents: Blockly.utils.toolbox.FlyoutItemInfoArray = [];\n    if (toolboxItem instanceof Blockly.ToolboxCategory) {\n      // Create a label node to go at the top of the category\n      contents.push({kind: 'LABEL', text: toolboxItem.getName()});\n      let itemContents = toolboxItem.getContents();\n\n      // Handle custom categories (e.g. variables and functions)\n      if (typeof itemContents === 'string') {\n        itemContents = [{custom: itemContents, kind: 'CATEGORY'}];\n      }\n      contents = contents.concat(itemContents);\n    }\n    return contents;\n  }\n\n  /**\n   * Updates the flyout's contents if it is visible.\n   */\n  override refreshSelection() {\n    if (this.getFlyout().isVisible()) {\n      if (this.refreshDebouncer) {\n        clearTimeout(this.refreshDebouncer);\n      }\n      this.refreshDebouncer = setTimeout(() => {\n        this.getFlyout().show(this.getInitialFlyoutContents());\n      }, 100);\n    }\n  }\n\n  /**\n   * Scrolls the flyout to display the newly selected category's contents.\n   *\n   * @param oldItem The previously selected toolbox category.\n   * @param newItem The newly selected toolbox category.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override updateFlyout_(\n    oldItem: Blockly.ISelectableToolboxItem | null,\n    newItem: Blockly.ISelectableToolboxItem | null,\n  ) {\n    if (newItem) {\n      this.getFlyout().scrollToCategory(newItem);\n      if (!this.getFlyout().isVisible()) {\n        this.getFlyout().show(this.getInitialFlyoutContents());\n      }\n    } else if (this.getFlyout().autoClose) {\n      this.getFlyout().hide();\n    }\n  }\n\n  /**\n   * Returns whether or not the toolbox should deselect the old category.\n   *\n   * @param oldItem The previously selected toolbox category.\n   * @param newItem The newly selected toolbox category.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override shouldDeselectItem_(\n    oldItem: Blockly.ISelectableToolboxItem | null,\n    newItem: Blockly.ISelectableToolboxItem | null,\n  ): boolean {\n    // Should not deselect if the same category is clicked again.\n    return !!(oldItem && oldItem !== newItem);\n  }\n\n  /**\n   * Gets a category by name.\n   *\n   * @param name Name of category to get.\n   * @returns Category, or null if not found.\n   * @internal\n   */\n  getCategoryByName(name: string): Blockly.ISelectableToolboxItem | null {\n    const category = this.getToolboxItems().find(\n      (item) =>\n        item instanceof Blockly.ToolboxCategory &&\n        item.isSelectable() &&\n        name === item.getName(),\n    );\n    if (!category) return null;\n    return category as Blockly.ISelectableToolboxItem;\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   *\n   * @param name Name of category to select.\n   * @internal\n   */\n  selectCategoryByName(name: string) {\n    const newItem = this.getCategoryByName(name);\n    if (!newItem) return;\n\n    const oldItem = this.selectedItem_;\n\n    if (oldItem && this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem);\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem);\n    }\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target/deletion area in pixels\n   * relative to the viewport.\n   *\n   * @returns The toolbox's bounding box. Null if drag target area should be\n   *     ignored.\n   */\n  override getClientRect(): Blockly.utils.Rect | null {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout();\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect();\n    }\n    return super.getClientRect();\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport type {ContinuousFlyout} from './ContinuousFlyout';\n\n/** Adds additional padding to the bottom of the flyout if needed. */\nexport class ContinuousFlyoutMetrics extends Blockly.FlyoutMetricsManager {\n  /**\n   * Returns the metrics for the scroll area of the continuous flyout's\n   * workspace. Adds additional padding to the bottom of the flyout if needed in\n   * order to make it possible  to scroll to the top of the last category.\n   *\n   * @param getWorkspaceCoordinates True to get the scroll metrics in\n   *     workspace coordinates, false to get them in pixel coordinates.\n   * @param cachedViewMetrics The view metrics if they have been previously\n   *     computed.\n   * @param cachedContentMetrics The content metrics if they have been\n   *     previously computed.\n   * @returns The metrics for the scroll container.\n   */\n  override getScrollMetrics(\n    getWorkspaceCoordinates?: boolean,\n    cachedViewMetrics?: Blockly.MetricsManager.ContainerRegion,\n    cachedContentMetrics?: Blockly.MetricsManager.ContainerRegion,\n  ) {\n    const scrollMetrics = super.getScrollMetrics(\n      getWorkspaceCoordinates,\n      cachedViewMetrics,\n      cachedContentMetrics,\n    );\n    const contentMetrics =\n      cachedContentMetrics || this.getContentMetrics(getWorkspaceCoordinates);\n    const viewMetrics =\n      cachedViewMetrics || this.getViewMetrics(getWorkspaceCoordinates);\n\n    if (scrollMetrics) {\n      scrollMetrics.height += (\n        this.flyout_ as ContinuousFlyout\n      ).calculateBottomPadding(contentMetrics, viewMetrics);\n    }\n    return scrollMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * A block inflater that caches and reuses blocks to improve performance.\n */\nexport class RecyclableBlockFlyoutInflater extends Blockly.BlockFlyoutInflater {\n  /**\n   * Whether or not block recycling is enabled.\n   */\n  recyclingEnabled = false;\n\n  /**\n   * Map from block type to block instance.\n   */\n  private recycledBlocks = new Map<string, Blockly.BlockSvg>();\n\n  /**\n   * Custom function to use for checking whether or not blocks can be recycled.\n   */\n  recycleEligibilityChecker?: (block: Blockly.Block) => boolean;\n\n  /**\n   * Creates a new block from the given block definition.\n   *\n   * @param blockDefinition The definition to create a block from.\n   * @param workspace The workspace to create the block on.\n   * @returns The newly created block.\n   */\n  override createBlock(\n    blockDefinition: Blockly.utils.toolbox.BlockInfo,\n    workspace: Blockly.WorkspaceSvg,\n  ): Blockly.BlockSvg {\n    const blockType = this.getTypeFromDefinition(blockDefinition);\n    return (\n      this.getRecycledBlock(blockType) ??\n      super.createBlock(blockDefinition, workspace)\n    );\n  }\n\n  /**\n   * Returns the type of a block from an XML or JSON block definition.\n   *\n   * @param blockDefinition The block definition to parse.\n   * @returns The block type.\n   */\n  private getTypeFromDefinition(\n    blockDefinition: Blockly.utils.toolbox.BlockInfo,\n  ): string {\n    let type: string | null | undefined;\n    if (blockDefinition['blockxml']) {\n      const xml =\n        typeof blockDefinition['blockxml'] === 'string'\n          ? Blockly.utils.xml.textToDom(blockDefinition['blockxml'])\n          : (blockDefinition['blockxml'] as Element);\n      type = xml.getAttribute('type');\n    } else {\n      type = blockDefinition['type'];\n    }\n\n    if (!type) {\n      throw new Error(\n        `Block type is not specified in block definition: ${JSON.stringify(\n          blockDefinition,\n        )}`,\n      );\n    }\n    return type;\n  }\n\n  /**\n   * Puts a previously created block into the recycle bin and moves it to the\n   * top of the workspace. Used during large workspace swaps to limit the number\n   * of new DOM elements we need to create.\n   *\n   * @param block The block to recycle.\n   */\n  private recycleBlock(block: Blockly.BlockSvg) {\n    const xy = block.getRelativeToSurfaceXY();\n    block.moveBy(-xy.x, -xy.y);\n    this.recycledBlocks.set(block.type, block);\n  }\n\n  /**\n   * Returns a block from the cache of recycled blocks with the given type, or\n   * undefined if one cannot be found.\n   *\n   * @param blockType The type of the block to try to recycle.\n   * @returns The recycled block, or undefined if one could not be recycled.\n   */\n  private getRecycledBlock(blockType: string): Blockly.BlockSvg | undefined {\n    const block = this.recycledBlocks.get(blockType);\n    this.recycledBlocks.delete(blockType);\n    return block;\n  }\n\n  /**\n   * Returns whether the given block can be recycled or not.\n   *\n   * @param block The block to check for recyclability.\n   * @returns True if the block can be recycled. False otherwise.\n   */\n  protected blockIsRecyclable(block: Blockly.Block): boolean {\n    if (!this.recyclingEnabled) return false;\n\n    if (this.recycleEligibilityChecker) {\n      return this.recycleEligibilityChecker(block);\n    }\n\n    // If the block needs to parse mutations, never recycle.\n    if (\n      block.mutationToDom ||\n      block.domToMutation ||\n      block.saveExtraState ||\n      block.loadExtraState\n    ) {\n      return false;\n    }\n\n    if (!block.isEnabled()) return false;\n\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field.referencesVariables()) return false;\n\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) return false;\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock = input.connection.targetBlock();\n        if (targetBlock && !this.blockIsRecyclable(targetBlock)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Disposes of the provided block.\n   *\n   * @param item The block to dispose of.\n   */\n  override disposeItem(item: Blockly.FlyoutItem) {\n    const element = item.getElement();\n    if (\n      element instanceof Blockly.BlockSvg &&\n      this.blockIsRecyclable(element)\n    ) {\n      this.removeListeners(element.id);\n      this.recycleBlock(element);\n    } else {\n      super.disposeItem(item);\n    }\n  }\n\n  /**\n   * Clears the cache of recycled blocks.\n   */\n  emptyRecycledBlocks() {\n    this.recycledBlocks.forEach((block) => block.dispose(false, false));\n    this.recycledBlocks.clear();\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {ContinuousFlyoutMetrics} from './ContinuousFlyoutMetrics';\nimport {RecyclableBlockFlyoutInflater} from './RecyclableBlockFlyoutInflater';\n\nexport interface LabelFlyoutItem extends Blockly.FlyoutItem {\n  // Blockly.FlyoutButton represents both buttons and labels; a label is just\n  // a borderless, non-clickable button.\n  getElement(): Blockly.FlyoutButton;\n}\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /**\n   * Target scroll position, used to smoothly scroll to a given category\n   * location when selected.\n   */\n  private scrollTarget?: number;\n\n  /**\n   * Map from category name to its position in the flyout.\n   */\n  private scrollPositions = new Map<string, number>();\n\n  /**\n   * The percentage of the distance to the scrollTarget that should be\n   * scrolled at a time. Lower values will produce a smoother, slower scroll.\n   */\n  protected scrollAnimationFraction = 0.3;\n\n  /**\n   * Prevents the flyout from closing automatically when a block is dragged out.\n   */\n  override autoClose = false;\n\n  /**\n   * Creates a new ContinuousFlyout.\n   *\n   * @param workspaceOptions The injection options for the flyout's workspace.\n   */\n  constructor(workspaceOptions: Blockly.Options) {\n    super(workspaceOptions);\n\n    this.getWorkspace().setMetricsManager(\n      new ContinuousFlyoutMetrics(this.getWorkspace(), this),\n    );\n\n    this.getWorkspace().addChangeListener((e: Blockly.Events.Abstract) => {\n      if (e.type === Blockly.Events.VIEWPORT_CHANGE) {\n        this.selectCategoryByScrollPosition(-this.getWorkspace().scrollY);\n      }\n    });\n\n    this.setRecyclingEnabled(true);\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   *\n   * @returns Toolbox that owns this flyout.\n   */\n  private getParentToolbox(): ContinuousToolbox | null {\n    const toolbox = this.targetWorkspace.getToolbox();\n    if (!toolbox || toolbox instanceof ContinuousToolbox) return toolbox;\n\n    console.warn(\n      'Expected a `ContinuousToolbox` instance but did not find one. ' +\n        'Make sure `registerContinuousToolbox()` has been called and the ' +\n        'continuous toolbox has been injected.',\n    );\n\n    return null;\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   */\n  private recordScrollPositions() {\n    this.scrollPositions.clear();\n    this.getContents()\n      .filter(this.toolboxItemIsLabel.bind(this))\n      .map((item) => item.getElement())\n      .forEach((label) => {\n        this.scrollPositions.set(\n          label.getButtonText(),\n          Math.max(0, label.getPosition().y - this.GAP_Y / 2),\n        );\n      });\n  }\n\n  /**\n   * Validates and typechecks that the given toolbox item represents a label.\n   *\n   * @param item The toolbox item to check.\n   * @returns True if the item represents a label in the flyout, and is a\n   *     Blockly.FlyoutButton.\n   */\n  protected toolboxItemIsLabel(\n    item: Blockly.FlyoutItem,\n  ): item is LabelFlyoutItem {\n    const element = item.getElement();\n    return !!(\n      item.getType() === 'label' &&\n      // Note that `FlyoutButton` represents both buttons and labels.\n      element instanceof Blockly.FlyoutButton &&\n      element.isLabel() &&\n      this.getParentToolbox()?.getCategoryByName(element.getButtonText())\n    );\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   *\n   * @param name Category name.\n   * @returns Scroll position for given category in workspace units, or null if\n   *     not found.\n   */\n  getCategoryScrollPosition(name: string): number | null {\n    const position = this.scrollPositions.get(name);\n    if (position === undefined) {\n      console.warn(`Scroll position not recorded for category ${name}`);\n    }\n    return position ?? null;\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   *\n   * @param position Current scroll position of the workspace.\n   */\n  private selectCategoryByScrollPosition(position: number) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget) return;\n\n    const scaledPosition = Math.round(position / this.getWorkspace().scale);\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (const [name, position] of [\n      ...this.scrollPositions.entries(),\n    ].reverse()) {\n      if (scaledPosition >= position) {\n        this.getParentToolbox()?.selectCategoryByName(name);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Scrolls the flyout to given position.\n   *\n   * @param position The Y coordinate to scroll to.\n   */\n  scrollTo(position: number) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.getWorkspace().getMetrics();\n    this.scrollTarget = Math.min(\n      position * this.getWorkspace().scale,\n      metrics.scrollHeight - metrics.viewHeight,\n    );\n\n    this.stepScrollAnimation();\n  }\n\n  /**\n   * Scrolls the flyout to display the given category at the top.\n   *\n   * @param category The toolbox category to scroll to in the flyout.\n   */\n  scrollToCategory(category: Blockly.ISelectableToolboxItem) {\n    const position = this.scrollPositions.get(category.getName());\n    if (position === undefined) {\n      console.warn(`Scroll position not recorded for category ${name}`);\n      return;\n    }\n    this.scrollTo(position);\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   */\n  private stepScrollAnimation() {\n    if (this.scrollTarget === undefined) return;\n    const currentScrollPos = -this.getWorkspace().scrollY;\n    const diff = this.scrollTarget - currentScrollPos;\n    if (Math.abs(diff) < 1) {\n      this.getWorkspace().scrollbar?.setY(this.scrollTarget);\n      this.scrollTarget = undefined;\n      return;\n    }\n    this.getWorkspace().scrollbar?.setY(\n      currentScrollPos + diff * this.scrollAnimationFraction,\n    );\n\n    requestAnimationFrame(this.stepScrollAnimation.bind(this));\n  }\n\n  /**\n   * Handles mouse wheel events.\n   *\n   * @param e The mouse wheel event to handle.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override wheel_(e: WheelEvent) {\n    // Don't scroll in response to mouse wheel events if we're currently\n    // animating scrolling to a category.\n    if (this.scrollTarget) return;\n\n    super.wheel_(e);\n  }\n\n  /**\n   * Calculates the additional padding needed at the bottom of the flyout in\n   * order to make it possible to scroll to the top of the last category.\n   *\n   * @param contentMetrics Content metrics for the flyout.\n   * @param viewMetrics View metrics for the flyout.\n   * @returns The additional bottom padding needed.\n   */\n  calculateBottomPadding(\n    contentMetrics: Blockly.MetricsManager.ContainerRegion,\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n  ): number {\n    if (this.scrollPositions.size === 0) return 0;\n\n    const lastPosition =\n      ([...this.scrollPositions.values()].pop() ?? 0) *\n      this.getWorkspace().scale;\n    const lastCategoryHeight = contentMetrics.height - lastPosition;\n    if (lastCategoryHeight < viewMetrics.height) {\n      return viewMetrics.height - lastCategoryHeight;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Returns the X coordinate for the flyout's position.\n   */\n  override getX(): number {\n    if (\n      this.isVisible() &&\n      // Make sure that this flyout is associated with a toolbox and not e.g.\n      // a simple flyout or the trashcan flyout.\n      this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&\n      this.targetWorkspace.getToolbox() &&\n      this.toolboxPosition_ !== Blockly.utils.toolbox.Position.LEFT\n    ) {\n      // This makes it so blocks cannot go under the flyout in RTL mode.\n      return this.targetWorkspace.getMetricsManager().getViewMetrics().width;\n    }\n\n    return super.getX();\n  }\n\n  /**\n   * Displays the given contents in the flyout.\n   *\n   * @param flyoutDef A string or JSON object specifying the contents of the\n   *     flyout.\n   */\n  override show(flyoutDef: Blockly.utils.toolbox.FlyoutDefinition | string) {\n    super.show(flyoutDef);\n    this.recordScrollPositions();\n    this.getWorkspace().resizeContents();\n    if (!this.getParentToolbox()?.getSelectedItem()) {\n      this.selectCategoryByScrollPosition(0);\n    }\n    this.getRecyclableInflater().emptyRecycledBlocks();\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   *\n   * @param func The function used to determine if a block is recyclable.\n   */\n  setBlockIsRecyclable(func: (block: Blockly.Block) => boolean) {\n    this.getRecyclableInflater().recycleEligibilityChecker = func;\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   *\n   * @param isEnabled True to allow blocks to be recycled, false otherwise.\n   */\n  setRecyclingEnabled(isEnabled: boolean) {\n    this.getRecyclableInflater().recyclingEnabled = isEnabled;\n  }\n\n  /**\n   * Returns the recyclable block flyout inflater.\n   *\n   * @returns The recyclable inflater.\n   */\n  protected getRecyclableInflater(): RecyclableBlockFlyoutInflater {\n    const inflater = this.getInflaterForType('block');\n    if (!(inflater instanceof RecyclableBlockFlyoutInflater)) {\n      throw new Error('The RecyclableBlockFlyoutInflater is not registered.');\n    }\n\n    return inflater;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides metrics to exclude the flyout from the viewport.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Computes metrics for a toolbox with an always open flyout. */\nexport class ContinuousMetrics extends Blockly.MetricsManager {\n  /**\n   * Computes the viewport size to not include the toolbox and the flyout.\n   * The default viewport includes the flyout.\n   *\n   * @param getWorkspaceCoordinates True to get the view metrics in workspace\n   *     coordinates, false to get them in pixel coordinates.\n   * @returns The width, height, top and left of the viewport in either\n   *     workspace coordinates or pixel coordinates.\n   */\n  override getViewMetrics(\n    getWorkspaceCoordinates = false,\n  ): Blockly.MetricsManager.ContainerRegion {\n    const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const svgMetrics = this.getSvgMetrics();\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n\n    if (this.workspace_.getToolbox()) {\n      // Note: Not actually supported at this time due to ContinuousToolbox\n      // only supporting a vertical flyout. But included for completeness.\n      if (\n        toolboxPosition == Blockly.TOOLBOX_AT_TOP ||\n        toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM\n      ) {\n        svgMetrics.height -= toolboxMetrics.height + flyoutMetrics.height;\n      } else if (\n        toolboxPosition == Blockly.TOOLBOX_AT_LEFT ||\n        toolboxPosition == Blockly.TOOLBOX_AT_RIGHT\n      ) {\n        svgMetrics.width -= toolboxMetrics.width + flyoutMetrics.width;\n      }\n    }\n    return {\n      height: svgMetrics.height / scale,\n      width: svgMetrics.width / scale,\n      top: -this.workspace_.scrollY / scale,\n      left: -this.workspace_.scrollX / scale,\n    };\n  }\n\n  /**\n   * Gets the absolute left and absolute top in pixel coordinates.\n   * This is where the visible workspace starts in relation to the SVG\n   * container, adjusted to not include the area behind the flyout.\n   *\n   * @returns The absolute metrics for the workspace.\n   */\n  override getAbsoluteMetrics(): Blockly.MetricsManager.AbsoluteMetrics {\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n    let absoluteLeft = 0;\n\n    if (\n      this.workspace_.getToolbox() &&\n      toolboxPosition == Blockly.TOOLBOX_AT_LEFT\n    ) {\n      absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;\n    }\n    let absoluteTop = 0;\n    if (\n      this.workspace_.getToolbox() &&\n      toolboxPosition == Blockly.TOOLBOX_AT_TOP\n    ) {\n      absoluteTop = toolboxMetrics.height + flyoutMetrics.height;\n    }\n    return {\n      top: absoluteTop,\n      left: absoluteLeft,\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Continuous-scroll toolbox and flyout that is always open.\n */\n\nimport * as Blockly from 'blockly/core';\n\nimport {ContinuousCategory} from './ContinuousCategory';\nimport {ContinuousFlyout} from './ContinuousFlyout';\nimport type {LabelFlyoutItem} from './ContinuousFlyout';\nimport {ContinuousMetrics} from './ContinuousMetrics';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {RecyclableBlockFlyoutInflater} from './RecyclableBlockFlyoutInflater';\n\nexport {\n  ContinuousCategory,\n  ContinuousFlyout,\n  ContinuousMetrics,\n  ContinuousToolbox,\n  LabelFlyoutItem,\n  RecyclableBlockFlyoutInflater,\n};\n\n/**\n * Registers the components of the continuous toolbox, replacing Blockly's\n * built-in defaults.\n */\nexport function registerContinuousToolbox() {\n  Blockly.registry.register(\n    Blockly.registry.Type.TOOLBOX_ITEM,\n    Blockly.ToolboxCategory.registrationName,\n    ContinuousCategory,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.METRICS_MANAGER,\n    'ContinuousMetrics',\n    ContinuousMetrics,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.FLYOUTS_VERTICAL_TOOLBOX,\n    'ContinuousFlyout',\n    ContinuousFlyout,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.TOOLBOX,\n    'ContinuousToolbox',\n    ContinuousToolbox,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.FLYOUT_INFLATER,\n    'block',\n    RecyclableBlockFlyoutInflater,\n    true,\n  );\n\n  Blockly.Css.register(`\n  .categoryBubble {\n    margin: 0 auto 0.125rem;\n    border-radius: 100%;\n    border: 1px solid;\n    width: 1.25rem;\n    height: 1.25rem;\n  }\n  .blocklyToolboxCategory {\n    height: initial;\n    padding: 3px 0;\n  }\n  .blocklyTreeRowContentContainer {\n    display: flex;\n    flex-direction: column;\n  }\n  .blocklyToolboxCategoryLabel {\n    margin: auto;\n  }\n  .blocklyToolboxCategoryLabel {\n    text-align: center;\n  }\n  `);\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ContinuousCategory","createLabelDom_","name","label","document","createElement","setAttribute","getId","textContent","classList","add","cssConfig_","createIconDom_","icon","style","backgroundColor","colour_","addColourBorder_","setSelected","isSelected","rowDiv_","htmlDiv_","dom","addClass","removeClass","aria","setState","State","SELECTED","ContinuousToolbox","init","super","getFlyout","show","getInitialFlyoutContents","getWorkspace","addChangeListener","e","type","BLOCK_CREATE","BLOCK_DELETE","BLOCK_CHANGE","refreshSelection","getToolboxItems","flatMap","convertToolboxItemToFlyoutItems","toolboxItem","contents","push","kind","text","getName","itemContents","getContents","custom","concat","isVisible","refreshDebouncer","clearTimeout","setTimeout","updateFlyout_","oldItem","newItem","scrollToCategory","autoClose","hide","shouldDeselectItem_","getCategoryByName","find","item","isSelectable","selectCategoryByName","selectedItem_","deselectItem_","shouldSelectItem_","selectItem_","getClientRect","flyout","ContinuousFlyoutMetrics","getScrollMetrics","getWorkspaceCoordinates","cachedViewMetrics","cachedContentMetrics","scrollMetrics","contentMetrics","getContentMetrics","viewMetrics","getViewMetrics","height","flyout_","calculateBottomPadding","RecyclableBlockFlyoutInflater","recyclingEnabled","recycledBlocks","Map","createBlock","blockDefinition","workspace","blockType","getTypeFromDefinition","getRecycledBlock","xml","textToDom","getAttribute","Error","JSON","stringify","recycleBlock","block","xy","getRelativeToSurfaceXY","moveBy","x","y","set","delete","blockIsRecyclable","recycleEligibilityChecker","mutationToDom","domToMutation","saveExtraState","loadExtraState","isEnabled","input","inputList","field","fieldRow","referencesVariables","isOptionListDynamic","connection","targetBlock","disposeItem","element","getElement","removeListeners","id","emptyRecycledBlocks","forEach","dispose","clear","ContinuousFlyout","constructor","workspaceOptions","scrollPositions","scrollAnimationFraction","setMetricsManager","VIEWPORT_CHANGE","selectCategoryByScrollPosition","scrollY","setRecyclingEnabled","getParentToolbox","toolbox","targetWorkspace","getToolbox","console","warn","recordScrollPositions","filter","toolboxItemIsLabel","bind","map","getButtonText","Math","max","getPosition","GAP_Y","getType","isLabel","getCategoryScrollPosition","position","scrollTarget","scaledPosition","round","scale","entries","reverse","scrollTo","metrics","getMetrics","min","scrollHeight","viewHeight","stepScrollAnimation","category","currentScrollPos","diff","abs","scrollbar","setY","requestAnimationFrame","wheel_","size","lastPosition","values","pop","lastCategoryHeight","getX","toolboxPosition","toolboxPosition_","Position","LEFT","getMetricsManager","width","flyoutDef","resizeContents","getSelectedItem","getRecyclableInflater","setBlockIsRecyclable","func","inflater","getInflaterForType","ContinuousMetrics","workspace_","svgMetrics","getSvgMetrics","toolboxMetrics","getToolboxMetrics","flyoutMetrics","getFlyoutMetrics","top","left","scrollX","getAbsoluteMetrics","absoluteLeft","absoluteTop","registerContinuousToolbox","register","Type","TOOLBOX_ITEM","registrationName","METRICS_MANAGER","FLYOUTS_VERTICAL_TOOLBOX","TOOLBOX","FLYOUT_INFLATER"],"sourceRoot":""}